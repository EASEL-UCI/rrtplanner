Getting Started
===============


Installation
------------

Installation is done with ``pip``

.. code-block:: bash

    pip install rrtplanner

How to Plan
-----------

Path Planning is the process of finding a viable path from one point to another in some configuration space. This package provides some example implementations of RRT, RRT*, and RRT*Informed planners. These planners can be used to plan in a two dimensional configuration space, with no differential constraints on the motion of the robot. This means that a path between two points is simply a straight line.

Plans are computed by these objects:

* :class:`rrtplanner.RRTStandard`
* :class:`rrtplanner.RRTStar`
* :class:`rrtplanner.RRTStarInformed`

Plans are computed on an OccupancyGrid, which is a MxN array of integers. This package considers a value of 0 to be free space, and anything other than 0 to be an obstacle. We can create random, boolean arrays with the built-in ``perlin_occupancygrid`` function:

.. code-block:: python

    from rrtplanner import perlin_occupancygrid
    og = perlin_occupancygrid(240, 240, 0.33)

This will create an occupancy grid (really, just an 400x400 array) of points, with blocks of 1 where obstacles are present and blocks of 0 that are free space.

.. important::

    Using Perlin noise often generates good random obstacles. However, it sometimes creates an occupancygrid with free space that is split -- from a given point, there is no guarantee that all free space is reachable if you are using the ``perlin_occupancygrid`` noise generator.

In real applications, occupancyGrids can be generated by e.g. a SLAM algorithm or pre-computed map.

With our occupancy grid, we are ready to plan.

First, we create the planner object. This object takes three important arguments: ``og``, which is the occupancy grid over which we want to plan, ``n`` which is the number of **attempted** sample points, and ``r_rewire``, which is the radius for which to rewire. 

As a general rule, we choose ``n`` appropriately, according to the amount of time we have to compute new plans vs the optimality of computed plans. When ``n`` is large, more samples are attempted, and so there are more opportunities to generate an optimal plan. When ``n`` is small, plan time is short, but plans are less optimal.

 We also want to choose ``r_rewire`` so that it is sized to the obstacle features. Very large values of ``r_rewire`` will result in the algorithm taking a long time to compute a plan, with little benefit, since obstacles block long straight-line paths. While very small values of ``r_rewire`` will result in the algorithm quickly finding a sub-optimal plan.

.. code-block:: python

    from rrtplanner import RRTStar, random_point_og
    n = 1200
    r_rewire = 80
    rrts = RRTStar(og, n, r_rewire)


Now, we can plan a path. We choose a start and a goal point randomly from the free space of the world, and call the ``RRTStar``'s ``plan`` method.

.. code-block:: python

    xstart = random_point_og(og)
    xgoal = random_point_og(og)
    T, gv = rrts.plan(xstart, xgoal)

The plan is computed, and we have two return values. The first is the tree itself, formatted as a `NetworkX DiGraph object <https://networkx.org/documentation/stable/reference/classes/digraph.html>`_ Points are stored in keys called ```pt`` and edges have the attribute ``cost``, which is the cost of the leaf node connected to that edge. The second return value is the vertex of the goal point on the tree.

Once our tree is created, we traverse it to find a path from vertex 0 to the goal vertex, and subsequently find each point in the order of that traversal:

.. code-block:: python


    path = rrts.route2gv(T, gv)
    path_pts = rrts.vertices_as_ndarray(T, path)

Then, we have computed our path and it is stored in ``path_pts``.

This package includes a number of plotting functions (which use `matplotlib`<https://matplotlib.org/>_) that can be used to visualize the 2-D world and plans in it.

.. code-block:: python

    from rrtplanner import plot_rrt_lines, plot_path, plot_og, plot_start_goal
    import matplotlib.pyplot as plt

    # create figure and ax.
    fig = plt.figure()
    ax = fig.add_subplot()

    # these functions alter ax in-place.
    plot_og(ax, og)
    plot_start_goal(ax, xstart, xgoal)
    plot_rrt_lines(ax, T)
    plot_path(ax, path_pts)

    plt.show()


We see the results of our plan. Because points and obstacles are generated randomly when you run this script, your result should bear a superficial resemblance to the figure below:

.. image:: _static/getting-started-plan.png